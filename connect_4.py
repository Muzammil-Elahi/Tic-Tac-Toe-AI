# -*- coding: utf-8 -*-
"""Connect 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ODuZ9WpvONUx1ee0JPyJ3NeIovCcNr20
"""

!pip install mcts

from copy import deepcopy
from mcts import mcts
from functools import reduce
import operator


class ConnectFour():
  def __init__(self):
    self.board = [[0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0]]
    self.currentPlayer = 1
  
  def getPossibleActions(self):
    possibleActions = []
    for i in range(len(self.board[0])):
      if self.board[0][i] == 0:
        possibleActions.append(Action(player=self.currentPlayer,x=i))
    return possibleActions
  
  def takeAction(self,action):
    newState = deepcopy(self)
    #newState.board[action.x][action.y]=action.player
    for i in range(5,0,-1):
      if(newState.board[i][action.x]!=0):
        newState.board[i-1][action.x]=action.player
    newState.currentPlayer = self.currentPlayer * -1
    return newState
  
  def isTerminal(self):
    
    for i in range(len(self.board)):
      for j in range(len(self.board[0])-3):
        if((abs((self.board[i][j] + self.board[i][j+1] + self.board[i][j+2] + self.board[i][j+3])))==4):
          return True # Checking rows
    for i in range(len(self.board)-3):#change to -2 if it doesnt work
      for j in range(len(self.board[0])):
        if(abs((self.board[i][j]+self.board[i+1][j]+self.board[i+2][j]+self.board[i+3][j]))==4):
          return True # Checking columns
    for i in range(len(self.board)-3):
      for j in range(len(self.board[0])-3):
        if(abs((self.board[i][j]+self.board[i+1][j+1]+self.board[i+2][j+2]+self.board[i+3][j+3]))==4):
          return True # Checking diagonal
    for i in range(5,2,-1):
      for j in range(6,3,-1):
#         print(self.board[i][j])
#         print(self.board[i-1][j-1])
#         print(self.board[i-2][j-2])
#         print(self.board[i-3][j-3])
        if(abs((self.board[i][j]+self.board[i-1][j-1]+self.board[i-2][j-2]+self.board[i-3][j-3]))==4):
          return True # Checking diagonal
    return reduce(operator.mul,sum(self.board,[]),1)
  
  
  def getReward(self):
    for i in range(len(self.board)):
      for j in range(len(self.board[0])-3):
        if(abs((self.board[i][j]+self.board[i][j+1]+self.board[i][j+2]+self.board[i][j+3]))==4):
          return ((self.board[i][j]+self.board[i][j+1]+self.board[i][j+2]+self.board[i][j+3]))/4 # rows
    for i in range(len(self.board)-3):#change to -2 if it doesnt work
      for j in range(len(self.board[0])):
        if(abs((self.board[i][j]+self.board[i+1][j]+self.board[i+2][j]+self.board[i+3][j]))==4):
          return ((self.board[i][j]+self.board[i+1][j]+self.board[i+2][j]+self.board[i+3][j])) /4 # columns
    for i in range(len(self.board)-3):
      for j in range(len(self.board[0])-3):
        if(abs((self.board[i][j]+self.board[i+1][j+1]+self.board[i+2][j+2]+self.board[i+3][j+3]))==4):
          return ((self.board[i][j]+self.board[i+1][j+1]+self.board[i+2][j+2]+self.board[i+3][j+3]))/4 
        # diagonal left to right
    for i in range(5,2,-1):
      for j in range(6,3,-1):
        if(abs((self.board[i][j]+self.board[i-1][j-1]+self.board[i-2][j-2]+self.board[i-3][j-3]))==4):
          return ((self.board[i][j]+self.board[i-1][j-1]+self.board[i-2][j-2]+self.board[i-3][j-3]))/4 
        # diagonal right to left
    return False
  
  
class Action():
  def __init__(self,player,x):
    self.player = player
    self.x = x
   




initialState = ConnectFour()
mcts = mcts(timeLimit=1)
while (initialState.isTerminal() == False):
  action = mcts.search(initialState=initialState)
  print(initialState.board)
  initialState = initialState.takeAction(action)